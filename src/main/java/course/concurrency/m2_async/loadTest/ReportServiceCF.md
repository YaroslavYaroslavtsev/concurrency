Cores: 6
MultiThreading : Yes

sleep()

| PoolSize  | ForkJoin | Single    | Fixed     | Cached    | 
|-----------|----------|-----------|-----------|-----------|
|           | 75422 ms |           |           |           |
| 1         |          | 300010 ms |           |           |
| 3         |          |           | 273020 ms |           |
| 6         |          |           | 137179 ms |           |
| 12        |          |           | 69388 ms  |           |
| 18        |          |           | 46715 ms  |           |
| 24        |          |           | 36174 ms  |           |
| 36        |          |           | 24133 ms  |           |
| unlimited |          |           |           | 15096 ms  |

Не очень хороший результат, объясняется тем что у ForkJoinPool.commonPool() размер пула
на один меньше чем число ядер т.е. 12-1 = 11 в нашем случае. Соответственно имеем 
время выполнения на уровне FixedThreadPool(12).
А как выяснили ранее для блокирующих задач лучше иметь пул
большего размера. Вывод: для блокирующих задач пул по умолчанию не лучший вариант. 

compute()

| PoolSize  | ForkJoin | Single   | Fixed    | Cached  | 
|-----------|----------|----------|----------|---------|
|           | 4587 ms  |          |          |         |
| 1         |          | 25397 ms |          |         |
| 3         |          |          | 12972 ms |         |
| 6         |          |          | 8653 ms  |         |
| 12        |          |          | 6654 ms  |         |
| 18        |          |          | 6080 ms  |         |
| 24        |          |          | 6989 ms  |         |
| 36        |          |          | 7119 ms  |         |
| unlimited |          |          |          | 7577 ms |

На вычислительной нагрузке ForkJoinPool.commonPool() дает наилучший результат, лучше чем
FixedThreadPool(12). Вывод: для вычислительных задач пул по умолчанию подходит лучше. 



CompletableFuture - просто удобный апи по работе с подзадачами, а всю работу выполняют те же экзекьюторы. Так что зависимости между типом задачи, числом ядер и количеством задач такие же.

Когда подойдёт экзекьютор по умолчанию?
Так как в стандартном экзекьюторе число потоков почти равно числу ядер, он идеально подойдёт для вычислительных задач.

Если в CompletableFuture отправляются блокирующие задачи, лучше определить свой экзекьютор.